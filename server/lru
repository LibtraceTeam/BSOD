/*
 *
 * Copyright (c) 2004 The University of Waikato, Hamilton, New Zealand.
 * Author:  Perry Lorier
 *          
 * All rights reserved.
 *
 * This code has been developed by the University of Waikato WAND 
 * research group. For further information please see http://www.wand.net.nz/
 *
 * This is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with bsod-server; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * $Id$
 *
 */



#ifndef LRU
#define LRU
// vim: syntax=cpp

#include <map>
#include <list>

/* This creates something that looks vaguely like a map<key_t,value_t>
 * but supports .pop() and .front() to get the oldest modified data
 */

template <class key_t, class value_t>
class lru_iterator {
	private: 
		typedef std::list<key_t> lru_t;
		typedef std::map<key_t,std::pair<lru_t::iterator,value_t> > data_t;
		data_t::const_iterator where;
	public:
		lru_iterator() { };
		lru_iterator(lru_iterator &x) : where(x.where) {};
		lru_iterator(data_t::const_iterator &_where) : where(_where) {};
		lru_iterator<key_t,value_t> &operator ++() {
			++where;
			return *this;
		}
		lru_iterator<key_t,value_t> operator ++(int) {
			lru_iterator <key_t,value_t> tmp;
			tmp=*this;
			++where;
			return tmp;
		}
		lru_iterator<key_t,value_t> &operator --() {
			--where;
			return *this;
		}
		lru_iterator<key_t,value_t> operator --(int) {
			lru_iterator <key_t,value_t> tmp;
			tmp=*this;
			--where;
			return tmp;
		}
		std::pair<key_t,value_t> operator *() const {
			return std::pair<key_t,value_t>(where->first,where->second.second);
		}
		// We hope that the -> operator will dereference this immediately
		// and the & will get optimised away.
		std::pair<key_t,value_t> *operator ->() const {
			return &(operator *());
		}
		bool operator ==( const lru_iterator<key_t,value_t> &b) {
			return where==b.where;
		}
		bool operator !=( const lru_iterator<key_t,value_t> &b) {
			return where!=b.where;
		}
};


template <class key_t,class value_t>
class lru {
	private: 
		typedef  std::list<key_t> lru_t;
		lru_t lru_list;
		typedef std::map<key_t,std::pair<lru_t::iterator,value_t> > data_t;
		data_t data;

	public:
		typedef lru_iterator<key_t,value_t> const_iterator;
		std::pair<key_t,value_t > front() {
			key_t & key = lru_list.front();
			return std::pair<key_t,value_t>(key,data[key].second);
		}
		void pop() {
			key_t key = lru_list.front();
			lru_list.pop_front();
			data.erase(key);
		}
		bool empty() const {
			return lru_list.empty();
		}
		size_t size() const {
			return data.size();
		}
		const_iterator begin(void) const {
			data_t::const_iterator i = data.begin();
			const_iterator ci(i);
			return ci;
		}

		const_iterator end(void) const {
			data_t::const_iterator i = data.end();
			const_iterator ci(i);
			return ci;
		}

		const_iterator find(key_t &key) const {
			data_t::const_iterator i =  data.find(key);
			const_iterator ci(i);
			return ci;
		}

		void erase(key_t k) {
			// Remove from the LRU
			lru_list.erase(data[k].first);
			// Remove from the map
			data.erase(k);
		}
		
		/* Add/update an item, updating the LRU at the same time */
		value_t &operator[](const key_t &k) {
			/* Does this already exist? */
			if (data.find(k) != data.end()) {
				/* Remove from the LRU */
				lru_list.erase(data[k].first);
			}
			/* Put it on the end */
			lru_list.push_back(k);
			/* Update the pointer */
			data[k].first=lru_list.end();
			data[k].first--;
			/* Return the data */
			return data[k].second;
		}
};

#endif
